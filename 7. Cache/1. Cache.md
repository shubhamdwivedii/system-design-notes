# Cache 

![cache1](./cache.png)

Caching **improves page load times** and can **reduce the load on your servers and databases**. 

In this model, the **dispatcher will first lookup if the request has been made before** and **try to find the previous result** to return, in order to save the actual execution. 


Databases often benefit from a uniform distribution of reads and writes across its partitions. 

Popular items can **skew the distribution**, causing **bottlenecks**.

**Putting a cache in front of a database can help absorb uneven loads in spikes in traffic**. 


### Client Caching 

Caches can be located on the **client side (OS or browser)**, **server side**, or in a **distinct cache layer (global cache)**.


### CDN Caching 

**CDNs** are considered **a type of cache**.


### Web Server Caching 

**Reverse Proxies** and caches such as **Varnish** can serve static and dynamic content directly. 

**Web servers can also cache requests**, returning responses without having to contact application servers. 


### Database Caching 

**Your database usually includes some level of caching in default configuration**, optimized for a generic use case. 

Tweaking these settings for specific usage patterns can furthur boost performance. 


### Application Caching 

**In-memory caches** such as **Memcached** and **Redis** are key-value stores between your application and your data storage. 

**Since the data is held in RAM, it is much faster than typical databases where data is stored on disk**. 

RAM is more limited than disk, so **cache invalidation** algorithms such as **Least Recently Used (LRU)** can help invalidate **'cold'** entries and keep **'hot'** data in RAM. 


**Redis has the following additional features:**

1. Persitence option 
2. Built-in data structures such as sorted sets and lists. 


There are multiple levels you can cache that fall into two general categories: **database queries** and **objects**

1. Row Level 
2. Query-Level 
3. Fully-Formed Serializable Objects 
4. Fully-Rendered HTML


**Generally, you should try to avoid file-based caching, as it makes cloning and auto-scaling more difficult**. 


### Caching At The Database Query Level 

Whenever you query the database, **hash the query as a key and store the result to the cache**.

This approach suffers from expiration issues: 

- Hard to delete a cached result with complex queries. 
- If one piece of data changes such as a table cell, you need to delete all cached queries that might include the changed cell. 


### Caching At The Object Level 

See your data as an object, similar to what you do in your application code. 

Have your application assemble the dataset from the database into a class instance or a data structure(s): 

- Remove teh object from cache if its underlying data has changed. 
- Allows for asynchronous processing: workers assemble objects by consuming the latest cached object. 

*Suggestions of what ot cache*:

1. User Sessions 
2. Fully Rendered Web Pages 
3. Activity Streams 
4. User Graph Data 


## When To Update The Cache 

Since you can only store a limited amount of data in cache, you'll need to determine which cache update strategy works best for your use case. 


### 1. Cache-Aside

![cache2](./cache_aside.png)

The application is responsible for reading and writing from storage. **The cache does not interact with storage directly**. 

The applicatoin does the following: 

1. Look for entry in cache, resulting in a cache miss. 
2. Load entry from the database 
3. Add entry to the cache 
4. Return entry